{"version":3,"sources":["webpack:///webpack/bootstrap ea36b6e11a43e162e358","webpack:///./src/index.js","webpack:///./src/utils.js"],"names":["combineChunks","fillInChunks","findAll","findChunks","autoEscape","sanitize","searchWords","textToHighlight","chunksToHighlight","chunks","totalLength","length","sort","first","second","start","reduce","processedChunks","nextChunk","prevChunk","pop","end","endIndex","Math","max","push","identity","filter","searchWord","escapeRegExpFn","regex","RegExp","match","exec","index","lastIndex","allChunks","append","highlight","forEach","chunk","value","str","replace"],"mappings":"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","file":"index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap ea36b6e11a43e162e358\n **/","/** @flow */\nexport { combineChunks, fillInChunks, findAll, findChunks } from './utils'\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","/**\n * Creates an array of chunk objects representing both higlightable and non highlightable pieces of text that match each search word.\n * @return Array of \"chunks\" (where a Chunk is { start:number, end:number, highlight:boolean })\n */\nexport const findAll = ({\n  autoEscape,\n  sanitize,\n  searchWords,\n  textToHighlight\n}) => (\n  fillInChunks({\n    chunksToHighlight: combineChunks({\n      chunks: findChunks({\n        autoEscape,\n        sanitize,\n        searchWords,\n        textToHighlight\n      })\n    }),\n    totalLength: textToHighlight.length\n  })\n)\n\n/**\n * Takes an array of {start:number, end:number} objects and combines chunks that overlap into single chunks.\n * @return {start:number, end:number}[]\n */\nexport const combineChunks = ({\n  chunks\n}) => {\n  chunks = chunks\n    .sort((first, second) => first.start - second.start)\n    .reduce((processedChunks, nextChunk) => {\n      // First chunk just goes straight in the array...\n      if (processedChunks.length === 0) {\n        return [nextChunk]\n      } else {\n        // ... subsequent chunks get checked to see if they overlap...\n        const prevChunk = processedChunks.pop()\n        if (nextChunk.start <= prevChunk.end) {\n          // It may be the case that prevChunk completely surrounds nextChunk, so take the\n          // largest of the end indeces.\n          const endIndex = Math.max(prevChunk.end, nextChunk.end)\n          processedChunks.push({start: prevChunk.start, end: endIndex})\n        } else {\n          processedChunks.push(prevChunk, nextChunk)\n        }\n        return processedChunks\n      }\n    }, [])\n\n  return chunks\n}\n\n/**\n * Examine text for any matches.\n * If we find matches, add them to the returned array as a \"chunk\" object ({start:number, end:number}).\n * @return {start:number, end:number}[]\n */\nexport const findChunks = ({\n  autoEscape,\n  sanitize = identity,\n  searchWords,\n  textToHighlight\n}) => {\n  textToHighlight = sanitize(textToHighlight)\n\n  return searchWords\n    .filter(searchWord => searchWord) // Remove empty words\n    .reduce((chunks, searchWord) => {\n      searchWord = sanitize(searchWord)\n\n      if (autoEscape) {\n        searchWord = escapeRegExpFn(searchWord)\n      }\n\n      const regex = new RegExp(searchWord, 'gi')\n\n      let match\n      while ((match = regex.exec(textToHighlight))) {\n        chunks.push({\n          start: match.index,\n          end: regex.lastIndex\n        })\n      }\n\n      return chunks\n    }, [])\n}\n\n/**\n * Given a set of chunks to highlight, create an additional set of chunks\n * to represent the bits of text between the highlighted text.\n * @param chunksToHighlight {start:number, end:number}[]\n * @param totalLength number\n * @return {start:number, end:number, highlight:boolean}[]\n */\nexport const fillInChunks = ({\n  chunksToHighlight,\n  totalLength\n}) => {\n  const allChunks = []\n  const append = (start, end, highlight) => {\n    if (end - start > 0) {\n      allChunks.push({\n        start,\n        end,\n        highlight\n      })\n    }\n  }\n\n  if (chunksToHighlight.length === 0) {\n    append(0, totalLength, false)\n  } else {\n    let lastIndex = 0\n    chunksToHighlight.forEach((chunk) => {\n      append(lastIndex, chunk.start, false)\n      append(chunk.start, chunk.end, true)\n      lastIndex = chunk.end\n    })\n    append(lastIndex, totalLength, false)\n  }\n  return allChunks\n}\n\nfunction identity (value) {\n  return value\n}\n\nfunction escapeRegExpFn (str) {\n  return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&')\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils.js\n **/"],"sourceRoot":""}